{
  "name": "nconf",
  "description": "Hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.",
  "version": "0.6.7",
  "author": {
    "name": "Nodejitsu Inc.",
    "email": "info@nodejitsu.com"
  },
  "maintainers": [
    {
      "name": "indexzero",
      "email": "charlie@nodejitsu.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/flatiron/nconf.git"
  },
  "keywords": [
    "configuration",
    "key value store",
    "plugabble"
  ],
  "dependencies": {
    "async": "0.1.x",
    "ini": "1.x.x",
    "optimist": "0.3.x",
    "pkginfo": "0.2.x"
  },
  "devDependencies": {
    "vows": "0.6.x"
  },
  "main": "./lib/nconf",
  "scripts": {
    "test": "vows test/*-test.js test/**/*-test.js --spec"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "readme": "# nconf [![Build Status](https://secure.travis-ci.org/flatiron/nconf.png)](http://travis-ci.org/flatiron/nconf)\r\n\r\nHierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.\r\n\r\n## Example\r\nUsing nconf is easy; it is designed to be a simple key-value store with support for both local and remote storage. Keys are namespaced and delimited by `:`. Lets dive right into sample usage:\r\n\r\n``` js\r\n  var fs    = require('fs'),\r\n      nconf = require('nconf');\r\n\r\n  //\r\n  // Setup nconf to use (in-order):\r\n  //   1. Command-line arguments\r\n  //   2. Environment variables\r\n  //   3. A file located at 'path/to/config.json'\r\n  //\r\n  nconf.argv()\r\n       .env()\r\n       .file({ file: 'path/to/config.json' });\r\n\r\n  //\r\n  // Set a few variables on `nconf`.\r\n  //\r\n  nconf.set('database:host', '127.0.0.1');\r\n  nconf.set('database:port', 5984);\r\n\r\n  //\r\n  // Get the entire database object from nconf. This will output\r\n  // { host: '127.0.0.1', port: 5984 }\r\n  //\r\n  console.log('foo: ' + nconf.get('foo'));\r\n  console.log('NODE_ENV: ' + nconf.get('NODE_ENV'));\r\n  console.log('database: ' + nconf.get('database'));\r\n\r\n  //\r\n  // Save the configuration object to disk\r\n  //\r\n  nconf.save(function (err) {\r\n    fs.readFile('path/to/your/config.json', function (err, data) {\r\n      console.dir(JSON.parse(data.toString()))\r\n    });\r\n  });\r\n```\r\n\r\nIf you run the above script:\r\n\r\n``` bash\r\n  $ NODE_ENV=production sample.js --foo bar\r\n```\r\n\r\nThe output will be:\r\n\r\n```\r\n  foo: bar\r\n  NODE_ENV: production\r\n  database: { host: '127.0.0.1', port: 5984 }\r\n```\r\n\r\n## Hierarchical configuration\r\n\r\nConfiguration management can get complicated very quickly for even trivial applications running in production. `nconf` addresses this problem by enabling you to setup a hierarchy for different sources of configuration with no defaults. **The order in which you attach these configuration sources determines their priority in the hierarchy.** Lets take a look at the options available to you\r\n\r\n  1. **nconf.argv(options)** Loads `process.argv` using optimist. If `options` is supplied it is passed along to optimist.\r\n  2. **nconf.env(options)** Loads `process.env` into the hierarchy.\r\n  3. **nconf.file(options)** Loads the configuration data at options.file into the hierarchy.\r\n  4. **nconf.defaults(options)** Loads the data in options.store into the hierarchy.\r\n  5. **nconf.overrides(options)** Loads the data in options.store into the hierarchy.\r\n\r\nA sane default for this could be:\r\n\r\n``` js\r\n  var nconf = require('nconf');\r\n\r\n  //\r\n  // 1. any overrides\r\n  //\r\n  nconf.overrides({\r\n    'always': 'be this value'\r\n  });\r\n\r\n  //\r\n  // 2. `process.env`\r\n  // 3. `process.argv`\r\n  //\r\n  nconf.env().argv();\r\n\r\n  //\r\n  // 4. Values in `config.json`\r\n  //\r\n  nconf.file('/path/to/config.json');\r\n\r\n  //\r\n  // Or with a custom name\r\n  //\r\n  nconf.file('custom', '/path/to/config.json');\r\n\r\n  //\r\n  // Or searching from a base directory.\r\n  // Note: `name` is optional.\r\n  //\r\n  nconf.file(name, {\r\n    file: 'config.json',\r\n    dir: 'search/from/here',\r\n    search: true\r\n  });\r\n\r\n  //\r\n  // 5. Any default values\r\n  //\r\n  nconf.defaults({\r\n    'if nothing else': 'use this value'\r\n  });\r\n```\r\n\r\n## API Documentation\r\n\r\nThe top-level of `nconf` is an instance of the `nconf.Provider` abstracts this all for you into a simple API.\r\n\r\n### nconf.add(name, options)\r\nAdds a new store with the specified `name` and `options`. If `options.type` is not set, then `name` will be used instead:\r\n\r\n``` js\r\n  nconf.add('user', { type: 'file', file: '/path/to/userconf.json' });\r\n  nconf.add('global', { type: 'file', file: '/path/to/globalconf.json' });\r\n```\r\n\r\n### nconf.use(name, options)\r\nSimilar to `nconf.add`, except that it can replace an existing store if new options are provided\r\n\r\n``` js\r\n  //\r\n  // Load a file store onto nconf with the specified settings\r\n  //\r\n  nconf.use('file', { file: '/path/to/some/config-file.json' });\r\n\r\n  //\r\n  // Replace the file store with new settings\r\n  //\r\n  nconf.use('file', { file: 'path/to/a-new/config-file.json' });\r\n```\r\n\r\n### nconf.remove(name)\r\nRemoves the store with the specified `name.` The configuration stored at that level will no longer be used for lookup(s).\r\n\r\n``` js\r\n  nconf.remove('file');\r\n```\r\n\r\n## Storage Engines\r\n\r\n### Memory\r\nA simple in-memory storage engine that stores a nested JSON representation of the configuration. To use this engine, just call `.use()` with the appropriate arguments. All calls to `.get()`, `.set()`, `.clear()`, `.reset()` methods are synchronous since we are only dealing with an in-memory object.\r\n\r\n``` js\r\n  nconf.use('memory');\r\n```\r\n\r\n### Argv\r\nResponsible for loading the values parsed from `process.argv` by `optimist` into the configuration hierarchy. See the [optimist option docs](https://github.com/substack/node-optimist/#optionskey-opt) for more on the option format.\r\n\r\n``` js\r\n  //\r\n  // Can optionally also be an object literal to pass to `optimist`.\r\n  //\r\n  nconf.argv({\r\n    \"x\": {\r\n      alias: 'example',\r\n      describe: 'Example description for usage generation',\r\n      demand: true,\r\n      default: 'some-value'\r\n    }\r\n  });\r\n```\r\n\r\n### Env\r\nResponsible for loading the values parsed from `process.env` into the configuration hierarchy.\r\n\r\n``` js\r\n  //\r\n  // Can optionally also be an Array of values to limit process.env to.\r\n  //\r\n  nconf.env(['only', 'load', 'these', 'values', 'from', 'process.env']);\r\n\r\n  //\r\n  // Can also specify a separator for nested keys (instead of the default ':')\r\n  //\r\n  nconf.env('__');\r\n  // Get the value of the env variable 'database__host'\r\n  var dbHost = nconf.get('database:host');\r\n\r\n  //\r\n  // Or use both options\r\n  //\r\n  nconf.env({\r\n    separator: '__',\r\n    whitelist: ['database__host', 'only', 'load', 'these', 'values']\r\n  });\r\n  var dbHost = nconf.get('database:host');\r\n```\r\n\r\n### Literal\r\nLoads a given object literal into the configuration hierarchy. Both `nconf.defaults()` and `nconf.overrides()` use the Literal store.\r\n\r\n``` js\r\n  nconf.defaults({\r\n    'some': 'default value'\r\n  });\r\n```\r\n\r\n### File\r\nBased on the Memory store, but provides additional methods `.save()` and `.load()` which allow you to read your configuration to and from file. As with the Memory store, all method calls are synchronous with the exception of `.save()` and `.load()` which take callback functions. It is important to note that setting keys in the File engine will not be persisted to disk until a call to `.save()` is made.\r\n\r\n``` js\r\n  nconf.file('path/to/your/config.json');\r\n  // add multiple files, hierarchically. notice the unique key for each file\r\n  nconf.file('user', 'path/to/your/user.json');\r\n  nconf.file('global', 'path/to/your/global.json');\r\n```\r\n\r\nThe file store is also extensible for multiple file formats, defaulting to `JSON`. To use a custom format, simply pass a format object to the `.use()` method. This object must have `.parse()` and `.stringify()` methods just like the native `JSON` object.\r\n\r\n### Redis\r\nThere is a separate Redis-based store available through [nconf-redis][0]. To install and use this store simply:\r\n\r\n``` bash\r\n  $ npm install nconf\r\n  $ npm install nconf-redis\r\n```\r\n\r\nOnce installing both `nconf` and `nconf-redis`, you must require both modules to use the Redis store:\r\n\r\n``` js\r\n  var nconf = require('nconf');\r\n\r\n  //\r\n  // Requiring `nconf-redis` will extend the `nconf`\r\n  // module.\r\n  //\r\n  require('nconf-redis');\r\n\r\n  nconf.use('redis', { host: 'localhost', port: 6379, ttl: 60 * 60 * 1000 });\r\n```\r\n\r\n## Installation\r\n\r\n### Installing npm (node package manager)\r\n```\r\n  curl http://npmjs.org/install.sh | sh\r\n```\r\n\r\n### Installing nconf\r\n```\r\n  [sudo] npm install nconf\r\n```\r\n\r\n## More Documentation\r\nThere is more documentation available through docco. I haven't gotten around to making a gh-pages branch so in the meantime if you clone the repository you can view the docs:\r\n\r\n```\r\n  open docs/nconf.html\r\n```\r\n\r\n## Run Tests\r\nTests are written in vows and give complete coverage of all APIs and storage engines.\r\n\r\n``` bash\r\n  $ npm test\r\n```\r\n\r\n#### Author: [Charlie Robbins](http://nodejitsu.com)\r\n#### License: MIT\r\n\r\n[0]: http://github.com/indexzero/nconf-redis\r\n",
  "readmeFilename": "README.md",
  "_id": "nconf@0.6.7",
  "dist": {
    "shasum": "20a44dd62e667020382e74258c118cbe256d7a8a"
  },
  "_resolved": "git+https://github.com/jmonster/nconf.git#b73b0e1a3746a67a7dfceaacc655ba22fc1ca9a3",
  "_from": "nconf@git+https://github.com/jmonster/nconf.git#v0.6.x"
}
